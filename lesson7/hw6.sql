--Preamble
/*
Почему при использовании следующих выражений в условии фильтрации бывают разные результаты?
t.dt between '2025-02-01' and '2025-03-14'
t.dt::date between '2025-02-01' and '2025-03-14'

Т.к. поле t.dt имеет тип данных TIMESTAMP то в нем хранится и дата и время т.е. значение типа "2025-01-01 07:09:34"
Соответственно, при выполнении запроса t.dt остается в типе TIMESTAMP, а значения '2025-02-01' и '2025-03-14'
НЕЯВНО преобразовываются в TIMESTAMP и получаются '2025-02-01 00:00:00' и '2025-03-14 00:00:00'.
Видим, что левая граница нас устраивает, а вот правая теряет все строки, в которых дата и время больше, чем "2025-03-14 00:00:00",
т.е. все транзакции, которые были с "2025-03-14 00:00:01" до "2025-03-14 23:59:59" отсекаются.
В случае, когда мы ЯВНО приводим столбец t.dt::date мы получаем убирем время у столбца t.dt и тем самым у нас попадают в рассмотрение
все значения за указанный период дат.
Можно не приводить явно к дате, но указывать следующее условие:
t.dt between '2025-02-01 00:00:00' and '2025-03-14 23:59:59', 
либо t.dt between '2025-02-01' and '2025-03-14' + interval '1' day - interval '1' second, 
но согласитесь,это неудобно.
БУДЬТЕ ВНИМАТЕЛЬНЫ! ИСПОЛЬЗУЙТЕ ЯВНОЕ ПРИВЕДЕНИЕ ТИПА ТАМ, ГДЕ ЭТО НЕОБХОДИМО!
*/

--1 Найти уникальные идентификаторы городов, в которых уникальное количество покупателей 
--за последние 5 месяцев без последних двух месяцев составляет от 30 тыс и больше.

/*
1-й способ решения задачи - через подзапрос.
Во внутреннем запросе необходимо соединить через внутреннее соединение (inner join/ join) таблицы
transactions и stores по ключу, store_id таблицы transactions и id таблицы stores.
так как требуется взять только за последние 5 месяцев без последних двух месяцев составляет то выставляем 
соответствующее условие в блоке where
в блоке select указываем рамки (s.city_id) в которых ищем УНИКАЛЬНОЕ количество покупателей (count(distinct customer_id)).
Этот запрос посчитает нужную нам метрику по каждому городу, а блок having отбросит те строки, которые не удовлетворяют условию -
"уникальное количество покупателей составляет от 30 тыс и больше".
После того, как все подсчитано, нам необходимо отбросить второй столбец, так как в условиях задачи требуется получить
только идентификаторы городов. Они будут уникальны, так как в подзапросе произошла группировка, следовательно, во внешнем запросе
указываем только city_id.
*/
select city_id from (
select s.city_id , count(distinct customer_id) uniq_cus
from public.transactions t
join public.stores s
	on t.store_id = s.id
where t.dt::date between now()::date - interval '5' month and now()::date - interval '2' month
group by 1
having count(distinct customer_id) >= 30000
)

/*
2-й способ решения задачи.
Необходимо соединить через внутреннее соединение (inner join/ join) таблицы
transactions и stores по ключу, store_id таблицы transactions и id таблицы stores.
так как требуется взять только за последние 5 месяцев без последних двух месяцев составляет то выставляем 
соответствующее условие в блоке where
в блоке select указываем рамки (s.city_id) в которых ищем УНИКАЛЬНОЕ количество покупателей (count(distinct customer_id)),
но теперь указываем способ подсчета только в блоке having и выставляем условие фильтрации групп (>= 30000).
Этот запрос посчитает нужную нам метрику по каждому городу, а блок having отбросит те строки, которые не удовлетворяют условию -
"уникальное количество покупателей составляет от 30 тыс и больше".
После того, как все подсчитано идентификаторы городов будут уникальны, так как была применена группировка по полю city_id.
*/
select
	s.city_id
from
	public.transactions t 
join public.stores s on
	s.id = t.store_id 
where
	t.dt >= current_date - interval '5' month
	and t.dt < current_date - interval '2' month
group by
	s.city_id
having 
	count(distinct t.customer_id) >= 30000
	

--2 Для каждой категории найти количество весовых товаров с ценой до 40.
/*
Так как требуется вывести имя категории то, помимо таблицы products нам потребуется таблица categories, 
которые необходимо соединить по соответствующему ключу. 
ВНИМАНИЕ! Хорошей практикой считается первым делом проверить таблицу products на тот момент, есть ли в ней товары без категории.
т.е. сделать запрос  select distinct category_id from products p и посмотреть, есть ли NULL-значения. Если таковых нет, то смело
используем inner join/ join, если имеются, то стоит посмотреть в сторону left join, чтоб не потерять товары без категории.
В нашем случае товаров без категории нет. Используем join по ключам products.category_id и categories.id.
Важным условием фильтрации является то, что товар весовой, а цена его до 40. Значит выставляем соответствующие условия
в блоке where.
Подсчет ведем с помощью функции count, группируем по имени категории из таблицы categories.
*/
select 
	c."name" ,
	count(*)
from products p
join categories c 
	on p.category_id = c.id
where 1=1
	and p.unit = 'кг'
	and p.price < 40
group by 1


--3 Найти в разрезе наименований категорий уникальное количество транзакций, в которых была куплена 1 ед/кг/шт/л (qnty) любого товара из этой категории.
/*
1-й способ
В данном задании нам необходимо спустится до деталей чеков, так как необходимо видеть количество купленных единиц каждого товара.
Второй момент это то, что нам необходимо вывести категории товаров, к которым можно добраться только через таблицу самых товаров.
Так как в чеках не может быть товаров, отсутствующих в таблице products, то используем inner join/ join, а с категориями поступаем так,
как я описал выше. после всех соединений необходимо выставить условие фильтрации на количество купленных товаров.
Важным моментом является то, что в условии сказано найти "уникальное количество транзакций". Т.е. если в одном чеке (транзакции) было 2,3,4 и т.д. товара(ов)
с количеством 1, то мы считаем этот чек как 1, поэтому метод подсчета используем count(distinct td.id).
*/
select c."name", count(distinct td.id)
from transactions_details td 
join products p
	on p.id = td.art_id
join categories c 
	on p.category_id = c.id
where td.qnty = 1
group by 1

/*
2-й способ аналогичен первому за исключением того, таблицы поменяны местами и условие фильтрации перенесено в условие соединения,
что позволяет уменьшить количество соединяемых строк и сразу отсеять лишнее.
*/
select
	c."name" ,
	count(distinct td.id)
from
	public.products p 
join public.transactions_details td on
	td.art_id = p.id
	and td.qnty = 1
join public.categories c on
	c.id = p.category_id 
group by
	c."name"
	
--4 Найти топ-10 уникальных наименований брендов, у которых самый дорогой по цене товар дешевле, чем у других брендов
/*
В задании необходимо найти максимальную цену товара каждого бренда и вывести 10 брендов с самыми низкими максимальными ценами.
Чтоб получить цену по каждому бренду, нам необходимо присоединить таблицу с товарами, так как у них указана цена. 
Далее, чтоб не использовать подзапросы необходимо то, поле, по которому мы будм сортировать (максимальная цена товара бренда)
отправить в оператор order by max(p.price) и не забыть группировку по имени бренда, так как нужны 10 наименьших цен, то сортируем
по возрастанию и отсекаем все, кроме первых 10
*/
select 
	b.name
from brands b 
join products p 
	on b.id = p.brand_id 
group by 1
order by max(p.price) 
limit 10

--5  Найти в разрезе полов/гендеров покупателей среднее количество транзакций на одного покупателя (с транзакцией) 
-- за период с 1 февраля 2025 по 14 марта 2025 включительно.
/*
Так как в условиях задачи написанно, что нас интересуют только покупатели, имеющие транзакции, то смело можем использовать inner join/ join, так как
покупатели без транзакций за указанный период отсекутся.
Для того, чтоб получить дробное число в результате действия count(distinct t.id)/count(distinct c.id) можно использовать 3 следующих способа:
1. Умножить результат на 1.0. Количество 0 после точки может быть произвольным
2. Сделать явное приведение типа, используя синтаксис SQL cast(count(distinct t.id) to float)/count(distinct c.id)
3. Сделать явное приведение типа, используя диалект PostgreSQL count(distinct t.id)::float/count(distinct c.id)
*/
select 
	c.gender,
	1.0*count(distinct t.id)/count(distinct c.id)
from transactions t  
join customers c
	on t.customer_id = c.id 
where t.dt::date between '2025-02-01' and '2025-03-14'
group by 1

select
	c.gender,
	(count(distinct t.id)::float) / count(distinct c.id)
from
	public.customers c 
join public.transactions t on
	t.customer_id = c.id
	and t.dt >= '2025-02-01'
	and t.dt < '2025-03-15'
group by
	c.gender
	
--6 Найти в разрезе идентификаторов городов количество транзакций 
--за период с 1 апреля 2025 на один действующий магазин (любой действующий, может быть и без транзакций).
/*
Важным условием задачи является то, что мы берем в выборку действующие магазины независисмо от того, есть ли в них транзакции.
Чтоб не потерять магазины, которые не имеют транзакций, мы используем left join.
Важный аспектом является то, что нам нужны транзакции за период с 1 апреля 2025. Многие, по неопытности, внесут условие фильтрации в блок WHERE
что превратить left join в обычный join, а значит мы потеряем те самые магазины без транзакций.
Поэтому необходимо условие фильтрации перенести в блок соединения. Таким образом К магазинам присоединятся их транзакции 
за указанный период, а если транзакций не было то магазин останется, а на месте транзакции будет null, чего мы и добиваемся.
Второе же условие фильтрации "действующий магазин" мы можем указать в блоке WHERE так как нас интересуют только открытые магазины.
Необходимую метрику считаем как результат деления количества транзакций в городе на количество магазинов в городе.
*/
select 
	s.city_id,
	1.0*count(t.id)/count(distinct s.id)
from stores s 
left join transactions t
	on t.store_id = s.id 
	and t.dt::date >= '2025-04-01'
where 1=1
	and s.close_dt is null
group by 1

--7 Для каждой категории необходимо определить долю количества купленных товаров этой категории с 1 марта 2025 ко всем транзакциям с 1 марта 2025.

/*
Для того, чтоб решить эту задачу нам потребуется использовать знания о подзапросах и о CROSS JOIN (напомню, что условие on 1=1 превращает join в cross join)
Для того, чтоб соотнести категории и количество купленных товаров воспользуемся таблицей products, к ней добавляем таблицу transactions_details,
которая содержит детали чеков и тем самым дает нам информацию о каждом купленном товаре.
В подзапросе мы считаем общее количество купленных товаров во всех категориях за указанный период. Это возвращает нам одно единственное значение.
Затем мы соединяем с помощью CROSS JOIN (или join on 1=1) результат подзапроса с остальными данными.
Далее, остается только посчитать долю в каждой категории. 
sum(td.qnty ) - считает сумму купленных ЕДИНИЦ ТОВАРОВ в каждой категории
max(sq.all_qnty) - берет то единственное количество всех товаров, что выдал подзапрос. Можно использовать min, avg, результат не изменится,
т.к. там единственное число. Важно только то, что нам необходимо получить его.
И не забываем ограничиваться на дату в блоке WHRERE
*/
select
	c."name" ,
	1.0*sum(td.qnty ) / max(sq.all_qnty)
from
	public.categories c 
join public.products p on
	p.category_id = c.id 
join public.transactions_details td on
	td.art_id = p.id 
join (
		select
			sum(qnty) as all_qnty
		from
			public.transactions
		where dt >= '2025-03-01'
	) sq on 1 = 1
where 1=1
	and td.dt >= '2025-03-01'
group by 1


--8 Для всех действующих или закрытых с 1 июля 2025 гипермаркетов необходимо найти среднюю площадь, 
--минимальную дату открытия и уникальное количество городов, в которых они действуют. 
--Данные необходимо вывести в разрезе года открытия гипермаркета.
/*
Задачу можно решить без использования соединений, для этого необходимо посмотреть в справочнике store_frmt тот id, которому соответсвует 
формат "hypermarket". И после этого в запросе использовать фильтрацию в блоке WHERE frmt = 3.
Но так как, наша домашняя работа подразумевает использование соединений, то рассмотрим способ решения через join.
Метрики описывать не буду, остановлюсь лишь на функции extract, которая позволяет достать любую часть даты в формате числа.
Здесь важно заметить, что мы должны не только ограничиться на формат магазина, но и на то, что магазин является действующим
либо закрыт с 1 июля 2025. Т.е. он открыт ИЛИ он закрыт с 1 июля 2025. Важно помнить, что в первую очередь выполняется оператор AND,
который является логическим УМНОЖЕНИЕМ, а только после умножения выполняется оператор OR логическое ИЛИ. Так что, как и в математике, 
чтоб OR выполнился раньше AND необходимо условие взять в скобки, как это сделано в запросе ниже.

Частая ошибка заключается в отсутствии скобок, когда пишут следующее:
WHERE 1=1
	and sf."name" = 'hypermarket'
	and s.close_dt::date >= '2025-07-01' or s.close_dt is null

В таком случае происходит следующее: условие комбинирует то, что написано через AND, т.е. оставит нам гипермаркеты, которые закрыты с 01.07.2025, 
а потом смотрит на второе условие, которое написано через OR и дополнительно показывает все магазины, у которых дата закрытия отсутствует.
Т.е., когда мы не используем скобки, мы говорим: покажи гипермаркеты, закрытые с 01.07.2025 или все магазины, которые открыты.
В случае, когда мы используем скобки, мы говорим: покажи гипермаркеты которые закрыты 01.07.2025 или работают до сих пор.
*/
select 
	extract(year from s.open_dt),
	avg(s.square) avg_sqr,
	min(s.open_dt) open_dt,
	count(distinct s.city_id)
from  stores s
join store_frmt sf 
	on sf.id = s.frmt 
where 1=1
	and sf."name" = 'hypermarket'
	and (s.close_dt::date >= '2025-07-01' or s.close_dt is null)
group by 1

--9 В разрезе идентификаторов городов вывести уникальное количество товаров (не штук, а конкретных товаров), единиц товаров (qnty) 
--в среднем на один магазин в соответствующем городе, купленных за период с апреля по май 2025 года включительно.
--Из полученной выборки оставить только данные по 5 городам, в которых третья метрика является наибольшей.
/*
Важно заметить, что нас просят показать уникальное КОЛИЧЕСТВО ТОВАРОВ, а значит нам придется использовать таблицу
с детализацией чеков, чтоб получить артикул каждого товара.
Не забываем про фильтрацию и сортировку и огриничение на 5 городов с наибольшим значением третьего столбца,
а идентификатор города можно получить из таблицы магазинов.
*/
select 
	s.city_id,
	count(distinct td.art_id),
	sum(td.qnty) / count(distinct td.store_id) asdas
from transactions_details td
join stores s 
	on td.store_id = s.id
where dt::date between '2025-04-01' and '2025-05-31'
group by 1
order by asdas desc
limit 5


--10 Найти уникальные наименования брендов, товары которых не покупали в первые 15 дней марта 2025 года.
/*
В этой задаче обращаем внимание, что нам нужны товары брендов, которые НЕ ПОКУПАЛИ, а значит мы присоединяем таблицу
с деталями чеков с помощью left join и не забываем, что условие на дату необходимо использовать именно в условии соединения
Помним, что те товары, которые не были куплены (отсутствовали в чеках) в указанный период будут иметь null в любом столбце таблицы
transactions_details, поэтому выбираем первый столбец td.id и вставляем его в блок where для поиска null значений.
*/
select distinct
	b."name" 
from products p
join brands b 
	on p.brand_id = b.id
left join transactions_details td
	on p.id = td.art_id 
	and dt::date between '2025-03-01' and '2025-03-15'
where td.id is null

--11 Для каждой пары "идентификатор города и наименование категории товара" определить общее количество купленных единиц товаров (qnty) 
--за первые 20 дней апреля 2025. В итоге оставить топ-10 пар, у которых суммарно больше всего купленных товаров (qnty).

/*
Соединяем таблицы для того, чтоб добраться до наименования категории, в блоке where используем фильтрацию по дате,
не забываем, что группировка идет по 2-м полям и что нам нужно получить топ-10 пар, у которых суммарно больше всего купленных товаров,
для чего делаем сортировку по сумме купленных единиц товаров и отсекаем лишнее с помощью limit
*/

select 
	s.city_id,
	c."name"	
from transactions_details td 
join stores s
	on s.id = td.store_id 
join products p 
	on p.id = td.art_id 
join categories c
	on c.id = p.category_id 
where 1=1
	and dt::date between '2025-04-01' and '2025-04-20'
group by 1,2
order by sum(td.qnty) desc
limit 10;
--1 Найти всех покупателей, совершивших покупки во вторую неделю апреля 2025 года, и вывести информацию о них 
--вместе с общей суммой потраченных денег и датой последней покупки.
/*
 В этом задании важно заметить, что неделя это период времени с понедельника по воскресенье включительно.
 Так как нам важен факт совершения покупки, то пользователи, которые их не совершали нас не интересуют.
 Учитывая все вышесказанное, выбираем тип соединения inner join/ join.
 Так как в выводе требуется показать имя и фамилию, то обязательно учитываем тот факт, что у нас могут быть полные тезки,
 что приведет к недостоверным данным, если мы будем группировать только по имени и фамилии. Например:
 
 customer_id | first_name | last_name | total_spent |  last_purchase_date |
 --------------------------------------------------------------------------
 	1		 |	Вася	  |	Пупкин	  | 	100	    |     2025-04-10      |
 --------------------------------------------------------------------------
 	5		 |	Вася	  |	Пупкин	  | 	200	    |     2025-04-14      |
 --------------------------------------------------------------------------
 
 Видим, что при совпадающих имени и фамилии у этих пользователей customer_id различный, а значит это разные люди.
 Следовательно, если мы просто уберем customer_id и сгруппируем по first_name и last_name (group by 
 c.first_name, c.last_name) , то получим строку:
 
 | first_name | last_name | total_spent |  last_purchase_date |
 --------------------------------------------------------------
 |	Вася	  |	Пупкин	  | 	300	    |     2025-04-14      |
 --------------------------------------------------------------
 
 А это нарушит логику нашей задачи, следовательно, мы должны оставить  customer_id в группировке, но убрать его из блока SELECT.
 */

select 
    c.first_name,
    c.last_name,
    sum(t.cheque_sum) as total_spent,
    max(t.dt) as last_purchase_date
from customers c
join transactions t 
	on c.id = t.customer_id
where 
	t.dt::date between '2025-04-07' and '2025-04-13'
group by 
	c.id, c.first_name, c.last_name
order by 
	last_purchase_date asc, total_spent desc
limit 5;



--2 Вывести список всех действующих магазинов с информацией о населении города, в котором они находятся. 
--Для каждого магазина показать общее количество транзакций за последние 9 месяцев.
/*
  В этой задаче нам важно учитывать тот факт, что транзакций в магазине может и не быть. Поэтому важно использовать left join
  с условием соединения, в том числе, по дате транзакции.
  
  Так как значение NULL является особенным и привычные нам математические операции к нему не применимы, то необходимо учесть этот факт
  в поле, где мы считаем сумму транзакций, т.к.:
  	1. любое число +/- NULL = NULL. Аналогично с умножением,делением,остатком от деления и т.д.
  	2. В случае сравнения ( =, >, <, >=, <= ) любого значения с NULL вы получите NULL.
  	3. Единственная операция, которую мы можем применить к NULL значению, это проверка на NULL значение. Т.е. id is NULL / id is not NULL,
  	что вернет нам True/False в зависимости от того, является ли знаение в ячейке NULL.
  Учитывая все вышесказанное если применить SUM() к сколько угодно не NULL значениям и прибавить к ним хотябы один NULL мы получим NULL.
  Знаем, что при left join, если в таблице, которая присоединяется, отсутствуют значения по ключу соединения, то они заполнятся значениям NULL.
  Что приведет к следующему виду:
  
   store_name  | city_population | monthly_transactions | monthly_revenue |  
 --------------------------------------------------------------------------
 Рога и копыта |	100500	     |			20156       | 	  10000001    |
 --------------------------------------------------------------------------
 ИП Матроскин  |	642		     |			0	        | 	  NULL		  |
 --------------------------------------------------------------------------
 
  Если добавить к этой таблицеще десяток строк, отсортировать по столбцу monthly_revenue и забрать первые 5 строк, то мы потеряем
  магазины, у которых не было выручки, т.к. NULL значение, в случае сортировки по возрастанию ставятся в конец списка, что для нашей 
  задачи неверно, т.к. эти магазины не имели выручки, а значит должны быть в первой пятерке.
  
  Чтоб решить эту проблему можно использовать функцию COALESCE. Эта функция принимает сколько угодно аргументов, перебирет их по очереди
  слева направо и выводит первое не NULL значение. Например:
  
  coalesce(null, 2, null, 3) вернет значение 2, так как первый аргумент null, а следующий после него 2. Остальные аргументы рассмотрены не будут. 
  coalesce(1, null, 2, null, 3) вернет 1, так как она не null.
  coalesce(null, null, null, null, 3) вернет 3, так как все предыдущие значения не являются null.
  
  В нашей задаче в эту функцию будет передаваться сумма траназакций:
  coalesce(sum(t.cheque_sum), 0), таким образом, если транакций не было, то sum(t.cheque_sum) будет null, что мы отлавливаем  с помощью
  функции coalesce и заменяем на 0.
  
  С учетом применения функции, наши магазины без транзакций не пропадут из вывода.
 */

select 
    s.name as store_name,
    c.population as city_population,
    count(t.id) as monthly_transactions,
    coalesce(sum(t.cheque_sum), 0) as monthly_revenue
from stores s
join cities c 
	on s.city_id = c.id
left join transactions t 
	on s.id = t.store_id 
    and t.dt::date >= current_date - interval '9 month'
where s.close_dt is null
group by 1,2
order by monthly_revenue 
limit 5;

--3 Найти всех покупателей в возрасте от 26 лет, которые не совершали покупки в последние 90 дней.
/*
 В этой задаче важно учесть тот факт, что мы ищем не просто тех, у кого последняя транзакция была более 90 дней назад,
 но и тех, кто никогда не совершал покупки. Следовательно, нам нужно найти тех, кто совершал покупки последние 90 дней (t.dt::DATE  >= CURRENT_DATE - INTERVAL '90 day')
 и их отбросить, оставив тех, кто нас интересует (t.id IS NULL).
 */
SELECT c.id  
FROM customers c 
LEFT JOIN  transactions t 
	ON t.customer_id = c.id 
  	AND t.dt::DATE  >= CURRENT_DATE - INTERVAL '90 day'
WHERE c.birth_dt <= CURRENT_DATE - INTERVAL '26 years'
   AND t.id IS NULL
GROUP BY c.id
ORDER BY c.birth_dt DESC, c.id
LIMIT 5;


--4 Найти час (среди всего дня), в который магазины имеют наибольшую выручку.
/*
 Смысл задания заключается в том, чтобы найти часы работы магазина, в которые покупатели имеют максимальную активность.
 напомню, что для извлечения любой части дат/времени можно использовать функцию  EXTRACT(<PART> FROM <DATE/DATETIME>) 
 */
SELECT 
    EXTRACT(HOUR FROM t.dt) AS hour_of_day
FROM stores s
JOIN transactions t 
	ON s.id = t.store_id
GROUP BY 1
order by SUM(t.cheque_sum) desc
limit 5;
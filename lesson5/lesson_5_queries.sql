--1. РАЗБОР ДЗ к УРОКУ 4.

----1
-- в этом запросе в блоке where приведены различные способы ограничения на дату
select 
	store_id,
	count(distinct id) id_cnt,
	sum(qnty) qnty	
from public.transactions
where
-- 1-й способ - ограничение с помощью неравенств
--	dt::date >= '2025-03-01' 
--	and dt::date <='2025-03-31'

-- 2-й способ - ограничение с помощью оператора BETWEEN. Важно учитывать, что включаются и левая и правая граница диапазона.
--  cast(dt as date) between '2025-03-01' and '2025-03-31'

-- 3-й способ - ограничение с помощью оператора extract, который извлекает ту часть даты, которая указана первой в скобках
--	extract(month from dt) = 3
--	and extract(year from dt) = 2025

-- 4-й способ - ограничение с помощью оператора date_trunc, который обрезает дату до минимальной в указанном периоде. В нашем случае month/
-- date_trunc('month', dt::date) = '2025-03-01'
group by 1
order by 2 desc, 3 asc
limit 1;

-- этот запрос решает задачу 4.1. Обратите внимание на то, что мы можем использовать агрегирующие функции в блоке ORDER BY. 
-- ограничение LIMIT 1 используется для того, чтоб вывести единственный store_id, который нас интересует
-- так же рекомендую испаользовать ЯВНОЕ приведение типа даты, т.е. dt::date либо cast(dt as date), так как при неявном преобразовании
-- это когда оптимизатор сам принимает решение преобразовывать или нет, бывают ошибки.
SELECT store_id
FROM transactions
WHERE dt::date >= '2025-03-01' AND dt < '2025-04-01'
GROUP BY store_id
ORDER BY 
    COUNT(*) DESC,  
    SUM(qnty) ASC   
LIMIT 1;

----2
-- этот запрос решает задание № 2. В нем мы используем только суммирование по интересующему нас полю и ограничиваемся на дату.
-- важно заметить, что в условиях задачи написанно, что права граница периода не является обязятельной к включению, поэтому 
-- при использовании оператора BETWEEN необходимо отнять один день от правой границы. 
select 
	sum(qnty)
from public.transactions
where 1=1 -- условие 1=1 используется для удобства отладки запроса и не является обязательным
	and store_id = 28
    -- отняли один день от правой границы
    and dt::date between '2025-04-06' and '2025-04-11'
    -- либо используем неравенство
    -- and dt::date >= '2025-04-06' and dt::date < '2025-04-12'

-- так же, теперь, когда мы знаем подзапросы, это задание можно объединить с решением задачи № 1 и получить следующий запрос:
select 
	sum(qnty)
from public.transactions
where 1=1 -- условие 1=1 используется для удобства отладки запроса и не является обязательным
    and dt::date >= '2025-04-06' and dt::date < '2025-04-12'
    and store_id in (
                        SELECT store_id
                    FROM transactions
                    WHERE dt::date >= '2025-03-01' AND dt < '2025-04-01'
                    GROUP BY store_id
                    ORDER BY 
                        COUNT(*) DESC,  
                        SUM(qnty) ASC   
                    LIMIT 1
    );

-- важным моментом является то, что символ ";" не ставится в конце подзапроса
	
----3
-- этот запрос решает задание № 3. Здесь важно обратить внимание на условие "хотя бы одна покупка от 35000". Значит нас интересует
-- только факт покупки, а следовательно, если в одном магазине было несколько таких покупок, то нам необходимо посчитать только одну.
-- Другими словами, нам необходимо посчитать количество уникальных store_id, в которых была покупка от 35000 рублей. 
-- Следовательно, мы будем использовать оператор DISTINCT, который уберет дубликаты значений.
select 
	count(distinct store_id)
from transactions
where 1=1
	and cheque_sum >= 35000

-- решение можно оформить через подзапрос без использования DISTINCT. спойлер - оно не является оптимальным
-- в подзапросе мы используем группировку по полю store_id, что позволяет нам избавиться от дубликатов, а во внешнем запросе
-- мы производим подсчет, теперь уже, уникальных значений store_id

select 
    count(store_id)
from (
        select 
            store_id
        from transactions
        where 1=1
            and cheque_sum >= 35000
        group by 1
);
	
----4
-- этот запрос решает задание № 4. Здесь важно ограничиться на указанные магазины, а так же использовать готовую функцию для рассчета процентиля
-- размер процентиля указывается как 80/100 = 0.8, в операторе WITHIN GROUP указывается поле, по которому мы производи расчет данной метрики
-- так как сумма чека является величиной непрерывной, то используется функция PERCENTILE_CONT
select 
	PERCENTILE_CONT(0.8) WITHIN GROUP (ORDER BY cheque_sum) AS percentile_80
from transactions 
where 1=1
	and store_id in (15, 82, 93, 94, 8)
	
----5
-- этот запрос решает задание № 5. Здесь важно ограничиться на указанное количество товаров, а так же использовать готовую функцию для рассчета процентиля
-- так как мы ищем МЕДИАНУ, то по правилам математики она является 50-м процентилем
-- размер процентиля указывается как 50/100 = 0.5, в операторе WITHIN GROUP указывается поле, по которому мы производи расчет данной метрики
-- так как дата и время чека является величиной дискретной, то используется функция PERCENTILE_DISC
SELECT 
    PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY dt) AS median_datetime
FROM transactions
WHERE qnty >= 50;


----6
-- этот запрос решает задание № 6. Здесь важно обратить внимание на условие фильтрации. Часто бывает, что строковые значение могут
-- быть записаны в разном регистре, т.е. слова Net, NET, neT являются разными с точки зрения регистра букв, а следовательно
-- компьютер воспринимает их как разные слова. Поэтому рекомендуется использовать функцию LOWER, которая приводит строку к нижнему
-- регистру. т.е. LOWER('AbCfGGG') = 'abcfggg'. Второй способ, который можно использовать в POSTGRESQL/CLICKHOUSE это оператор ILIKE. Он не является
-- чувствительным к регистру и потому для него строки 'AbCfGGG' и 'abcfggg' являются идентичными.
select 
	c.first_name 
from customers c 
where 1=1
	and lower(c.email) like '%.net'
    --and c.email ilike '%.net'
group by 1
order by count(*) desc
limit 1;

----7
-- В этом запросе продемонстрированы способы получения разницы между двумя датами
-- поле age_1: здесь функция age возращает интервал следующего вида "ХХ years ХХ mons ХХ day", а с помощью extract мы извлекаем количество полных лет.
-- поле age_2: здесь мы используем разницу двух дат, которая возвращает количество дней между двумя датами, а потом делим на 365.25, 
-- так как раз в 4 года у нас високосный год длиной 366 дней. В итое получаем дробное значение лет
-- поле age_3: здесь мы используем то же действие что в поле age_2, но применяем к нему функцию floor, которая "округляет вниз". т.е. значения 27.1 и 27.9
-- будут округлены одинаково до 27.
-- поле age_4: здесь мы используем то же действие что в поле age_2, но применяем к нему функцию ceil, которая "округляет вверх". т.е. значения 27.1 и 27.9
-- будут округлены одинаково до 28.
-- поле age_5: здесь мы используем то же действие что в поле age_2, но применяем к нему функцию round, которая согласно правилам математики. 
-- т.е. значения от 27 до 27.4 будут округляться до 27, а значения от 27.5 до 27.9 будут округлены до 28.
select 
	extract('year' from  age('2025-09-01'::date, birth_dt)) age_1,
	('2025-09-01'::date - birth_dt) /365.25 age_2,
    floor(('2025-09-01'::date - birth_dt) /365.25) age_3,
    ceil(('2025-09-01'::date - birth_dt) /365.25) age_4,
    round(('2025-09-01'::date - birth_dt) /365.25, 0) age_5
from customers c 
where 1=1

-- учитывая все, что сказано выше в п.7 заключаем, что нашу задачу можно решить, используя в условии способы из полей age_1, age_2, age_3.
-- но не стоит забывать про такой тип данных как ИНТЕРВАЛ. 
/* Попрошу заметить, что здесь используется многострочный комментарий!

Интервал можно прибавлять и отнимать от значений даты и даты-времени. Данное действие возвращает дату, смещенную на указанный интервал
Синтаксис выглядит следующим образом:
DATE +(-) INTERVAL 'X' PERIOD, где:
 - DATE это дата, с которой необходимо произвести операцию
 - +(-) операция, которую хотим произвести (прибавить или отнять)
 - INTERVAL - ключевое слово, которое определяет, что сейчас будет указан интервал
 - Х - количество единиц, которые прибавляются или отнимаются. Обязательно указывается в одинарных кавычках.
 - PERIOD - ключевое слово, которое определяет период (год, месяц, день, час и тд)
*/
-- этот запрос решает задание № 7. Здесь важно ограничиться на возраст покупателя.
select 
	count(*)	
from customers c 
where 1=1
	and extract('year' from  age('2025-09-01'::date, birth_dt)) >= 40
    --либо вариант с интервалом. Здесь мы прибавляем 40 лет к дате рождения и смотрим, чтоб она не была больше 2025-09-01.
    --так мы поймем, что человеку исполнилось 40 лет на 2025-09-01.
    and birth_dt + interval '40' year <= '2025-09-01'

----8
-- этот запрос решает задание № 7. Здесь важно ограничиться на месяц покупки и использовать агрегатные функции min/max.
select 
	max(qnty) - min(qnty)
from transactions
where 1=1
	and date_trunc('month', dt::date) = '2025-04-01';


--------##########################-----------

--2. Использованеи подзапросов

--Выберем всех покупателей из таблицы customers, которые имеют покупки более чем на 1000 рублей.
--здесь используем подзапрос в блоке WHERE, в котором собираем customer_id из таблицы transactions, которые совершили покупки более чем на 1000 рублей
--далее ограничиваемся, что поле id таблицы customers содержит id тех пользователей, которые нас интересуют
SELECT *
FROM customers
WHERE id IN (
    SELECT customer_id
    FROM transactions
    WHERE cheque_sum > 1000
);

-- Так как мы еще не знаем, что такое соединение таблиц, то можем использовать подзапрос в блоке SELECT
-- для того, чтоб получить название города, в котором находится магазин. Для этого будем использовать
-- коррелированный подзапрос (т.е. вложенный запрос зависит от внешнего запроса "id = s.city_id")
-- НАПОМИНАЮ, ЧТО ИСПОЛЬЗОВАНИЕ ПОДЗАПРОСА В БЛОКЕ SELECT ЯВЛЯЕТСЯ КРАЙНЕ ПЛОХОЙ ПРАКТИКОЙ!
SELECT 
    s.name,
    s.city_id,
    (SELECT name FROM cities WHERE id = s.city_id) as city_name
FROM stores s;

-- Рассмотрим использование подзапроса в блоке FROM. Здесь мы предварительно, в подзапросе, производим фильтрацию на покупки, 
-- которые были совершены начиная с 2025-01-01 и выбираем столбцы store_id, cheque_sum, а после этого, во внешнем запросе, производим расчет 
-- среднего значения чека по магазину.
-- ВАЖНОЕ УТОЧНЕНИЕ! Если вы используете подзапрос в блоке FROM то ему желательно назначить alias. В данном случае испольуется "as recent_transactions"
-- в противном случае, в некоторых СУБД, вы можете получить ошибку 
SELECT 
    store_id,
    AVG(cheque_sum) as avg_cheque
FROM (
    SELECT store_id, cheque_sum
    FROM transactions
    WHERE dt >= '2025-01-01'
) as recent_transactions
GROUP BY store_id;

-- Рассмотрим использование подзапроса в блоке HAVING. Здесь вы можете видеть, что используется подзапрос в подзапросе. Итак:
-- в подзапросе store_stats мы считаем количество покупок в каждом магазине, а после, в запросе уровнем выше, с помощью действия AVG(transaction_count)
-- получаем среднее количество покупок по всем магазинам.
-- Теперь рассмотрим самый верхних запрос. В нем мы считаем количество покупок в каждом магазине, но с помощью оператора HAVING
-- мы отсекаем те магазины, в которых количество покупок меньше среднего количества по всем магазинам. Т.е. меньше результатов нашего подзапроса 
-- с операцией AVG(transaction_count).
SELECT 
    store_id,
    COUNT(*) as transaction_count
FROM transactions
GROUP BY store_id
HAVING COUNT(*) > (
    SELECT AVG(transaction_count)
    FROM (
        SELECT store_id, COUNT(*) as transaction_count
        FROM transactions
        GROUP BY store_id
    ) as store_stats
);


-- А теперь рассмотрим такой интересный оператор как EXISTS. Этот оператор проверяет, существует ли результат запроса.
-- Результат запроса существует, если запрос возвращает хотя бы одну строчку с данными, в противном случае запрос возвращает пустоту,
-- а значит результата нет.
-- В запросе ниже мы используем коррелированый запрос, в котором проверяем, есть ли в таблице stores магазины из города cities с форматом frmt = 1
-- и выводим название таких городов из таблицы cities.
-- ВАЖНОЕ УТОЧНЕНИЕ! В подзапросе в блоке SELECT можно указывать любое из полей, все поля, либо константу (как в нашем случае). Т.к. нам важен только факт
-- существования резульата, то указывается константа, для более оптимального выполнения запроса.
SELECT 
    c.name as city_name
FROM cities c
WHERE EXISTS (
    SELECT 1
    --, *
    --, id
    --, frmt
    FROM stores s
    WHERE s.city_id = c.id AND s.frmt = 1
);
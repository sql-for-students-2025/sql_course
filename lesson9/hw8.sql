/*
Найти 10 покупателей, у которых самый многообещающий тренд по сумме транзакции. Многообещающий тренд определяем, как наибольшее значение наклона 
прогноза следующей суммы транзакции покупателя на основе линейной регрессии его покупок.
Формулу линейной регресии определяем на основе скользящего среднего сумм транзакций покупателя за первое полугодие 2025 года с шириной окна 3, 
включая текущую транзакцию. У покупателя за отчетный период должно быть минимум 6 транзакций (в среднем одна транзакция за полгода).
Подсказка: По каждому покупателю считаем скользящее среднее трех последних транзакций, включая текущую. Скользящие средние, у которых нет трех транзакций 
исключаем, так как у них нет достаточного числа событий.
Далее по каждому покупателю вычисляем коэффициент k модели линейной регресии на основе его транзакций. 
В итоге оставляем 10 покупателей с наибольшим коэффициентом k.
Запрос должен вернуть две колонки: идентификатор покупателя, значение коэффициента k.
Ключевые слова и фразы: ROW_NUMBER, AVG, LIMIT, PARTITION BY, PRECEDING, CURRENT ROW, REGR_SLOPE (PG), simpleLinearRegression (CH)

Простыми словами:
Найдите 10 клиентов, которые покупают регулярно (минимум 6 раз за полгода) и у которых сумма их покупок стабильно и сильно растёт от покупки к покупке.

**/

with pre1 as (
	select 
		customer_id,
		--считаем скользящее среднее между текущей покупкой и двумя предыдущими
		avg(cheque_sum) over (partition by customer_id order by dt rows between 2 preceding and current row) avg_s, 
		--нумеруем транзакции в порядке возрастания без пропуска значений
		row_number() over (partition by customer_id order by dt) rn
	from transactions
	where 
		--фильтруем дату покупки
		dt::date between '2025-01-01' and '2025-06-30'
)
select 
	customer_id,
	--считаем тренд по сумме транзакции
	REGR_SLOPE(avg_s, rn) regression_k
from pre1
where 1=1
	--отсеиваем тех, у кого меньше 6 транзакций
	and customer_id in (select customer_id from pre1 group by 1 having max(rn) >=6)
	--убираем из расчета все транзакции, которые имеют номер меньше 3, так как они не имеют достаточного числа событий 
	and rn >= 3
group by 1
order by 2 desc
limit 10;


/*
Вычислить среднюю, минимальную и максимальную дискретность транзакций на покупателя в разрезе категорий "Кофе" и "Сахар" 
за период с марта 2025 по июль 2025 включительно.
Дискретность считаем изначально на уровне покупателя, а затем уже агрегируем до уровня категории.
Если в один и тот же день один и тот же покупатель совершил несколько транзакций в одной и той же категории, 
то считаем, что это одно событие для расчета дискретности.
Важно понимать, что в один и тот же день один и тот же покупатель мог совершить транзакции в разных категориях. 
В этом случае предыдущая транзакция в категории у этого покупателя могла быть в разные даты.
Подсказка: в эталонном запросе 4 CTE, может быть и меньше, но в процессе обучения точно не стоит бояться мельчить.
Подсказка: в ClickHouse если дата не найдена, то будет автоматическая подстановка 01.01.1970.
Запрос должен вернуть 4 колонки: наименование категории, среднее количество дней между датами транзакций у покупателей, 
минимальное количество дней между датами транзакций у покупателей, максимальное количество дней между датами транзакций у покупателей
Ключевые слова и фразы: JOIN, LAG, AVG, MIN, MAX, PARTITION BY, UNBOUNDED PRECEDING AND CURRENT ROW (CH)
*/

with pre1 as (
select 
	td.customer_id,
	c.name cat_name,
	dt::date dt,
	--нумеруем транзакции в пределах покупатель-дата_покупки-категория для того, чтоб в следующем шаге отсеять повторные покупки в тот же день
	row_number() over (partition by td.customer_id, dt::date, p.category_id order by dt) rn
from transactions_details td 
join products p 
	on p.id = td.art_id 
join categories c 
	on c.id = p.category_id 
where 1=1
	--фильтруем категории и дату
	and c."name" in ('Кофе','Сахар')
	and dt::date between '2025-03-01' and '2025-07-31'
),
pre2 as (
select 
	customer_id,
	cat_name,
	dt,
	--забираем дату предыдущей покупки в пределах покупатель-категория
	lag(dt) over (partition by customer_id, cat_name order by dt) prev_dt
from pre1
where rn = 1 --делаем фильтр для того, чтоб оставить только первую покупку за день
)
select --считаем требуемые показатели
	cat_name,
	avg(dt-prev_dt),
	min(dt-prev_dt),
	max(dt-prev_dt)
from pre2
group by 1


/*
3. Вычислить общую сумму транзакций, в которых был хотя бы один товар из категории "Сахар", за все время в разрезе 
четных-нечетных (по дате совершения) транзакций. Признак четной-нечетной транзакции определяем для каждого покупателя отдельно.
Подсказка: функция для нахождения остатка от деления - mod.
Подсказка: в Clickhouse дополнительно к сортировке внутри оконной рамки необходимо добавить сортировку по количеству, 
иначе СУБД по одному и тому же коду возвращает разный результат при каждом очередном перезапуске.
Запрос должен вернуть 2 колонки: признак четная-нечетная (0 - четная, 1 - нечетная) транзакция, сумма покупок.
Ключевые слова и фразы: ROW_NUMBER, PARTITION BY
*/

with pre1 as (
select distinct --собираем уникальные идетификатлры транзакций с категорией сахар
	case when c."name" in ('Сахар') then td.id end id
from transactions_details td 
join products p 
	on p.id = td.art_id 
join categories c 
	on c.id = p.category_id 
where 1=1
),
pre2 as (
select 
	t.cheque_sum,
	--нумеруем транзакции в рамках каждого покупателя
	row_number() over (partition by t.customer_id order by dt) rn
from pre1 td
join transactions t 
	on td.id = t.id 
)
select
	rn%2, --получаем остаток от деления 0/1
	sum(cheque_sum) --считаем сумму покупок
from pre2
group by 1


/*
4. Найти топ-10 покупателей у которых наибольшая доля суммы одной транзакции по отношению ко всем их транзакциям за все время. 
Другими словами наибольший вклад одной транзакции покупателя в выручку по нему.
При этом у рассматриваемых покупателей за все время должно быть более 6 транзакций. Результат необходимо дополнительно отсортировать 
по возрастанию идентификатора покупателя.
Подсказка: ClickHouse не делает автоматического перевода типа данных numeric во float при вычислении доли, требуется явное преобразование.
Запрос должен вернуть 2 колонки: идентификатор покупателя и долю суммы одной какой-то его транзакции к сумме всех транзакций этого покупателя.
Ключевые слова и фразы: COUNT, SUM, PARTITION BY, ORDER, LIMIT
*/

with pre1 as (
select 
	t.customer_id ,
	cheque_sum,
	--считаем количество покупок на каждого покупателя
	count(t.id) over (partition by customer_id) rn
from transactions t 
)
select 
	customer_id,
	---считаем целевой показатель как отношение суммы текущей покупки к сумме всех покупок клиента
	cheque_sum / sum(cheque_sum) over (partition by customer_id )  cus_share
from pre1
where 1=1
	-- отсеиваем клиентов, у которых меньше 6 покупок
	and rn >=6
order by 2 desc
limit 10;

/*
5. Посчитать количество уникальных покупателей у которых их возраст полных лет от текущей даты больше, чем средний возраст 
по базе для их имени, увеличенный на стандартное отклонение по возрасту для их имени.
Другими словами нас интересуют покупатели, у которых возраст в настоящий момент больше (средний возраст по их имени + 
стандартное отклонение возраста для их имени).
Подсказка: функции для нахождения стандартного отклонения stddev (PG) и stddevSamp (CH), она тоже является оконной.
Запрос должен вернуть одно значение: количество покупателей.
Ключевые слова и фразы: AVG, STDDEV, PARTITION BY
*/

with pre1 as (
	select 
		id,
		--считаем возраст нашего клиента
		extract(year from age(c.birth_dt)) c_age,
		--считаем средний возраст клиента в рамках имени и доьбавляем стандартное отклонение возраста в рамках имени
		avg(extract(year from age(c.birth_dt))) over (partition by first_name) + stddev(extract(year from age(c.birth_dt))) over (partition by first_name)  avg_age
	from customers c 
)
select count(distinct id) --считаем количество уникальных пользователей
from pre1
where 1=1
	--фильтруемся в соответствии с условием задачи
	and c_age > avg_age;